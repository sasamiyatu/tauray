
#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#include "svgf.glsl"
#include "projection.glsl"
#include "gbuffer.glsl"
#include "color.glsl"

layout(binding = 0, set = 0, rgba32f) uniform readonly image2DArray in_color;
layout(binding = 1, set = 0, rgba32f) uniform image2DArray out_color;
layout(binding = 2, set = 0, rgba32f) uniform image2DArray in_linear_depth;
layout(binding = 3, set = 0, rgba32f) uniform image2DArray color_hist;
layout(binding = 4, set = 0, rgba32f) uniform image2DArray current_moments;
layout(binding = 5, set = 0, rgba32f) uniform image2DArray moments_hist;
layout(binding = 6, set = 0, rgba32f) uniform image2DArray in_albedo;
layout(binding = 7, set = 0, rgba32f) uniform image2DArray in_normal;
layout(binding = 8, set = 0, rgba32f) uniform image2DArray in_specular;
layout(binding = 9, set = 0, rgba32f) uniform image2DArray out_specular;

layout (local_size_x = 16, local_size_y = 16) in;

layout(push_constant) uniform push_constant_buffer
{
    ivec2 size;
    int parity;
    int level;
    int stride;
    int iteration_count;
} control;

void main()
{
    const ivec3 p = ivec3(gl_GlobalInvocationID.xyz);
    if(all(lessThan(p.xy, control.size)))
    {
        vec3 moments = imageLoad(current_moments, p).rgb;
        float hist_len = moments.z;
        vec4 c_center = imageLoad(in_color, p);
        vec4 spec_center = imageLoad(in_specular, p);
        if (hist_len < 4.0)
        {
            float sum_w = 0.0;
            vec3 sum_color = vec3(0.0);
            vec2 sum_moments = vec2(0.0);
            vec3 sum_specular = vec3(0.0);
            float lum_center = rgb_to_luminance(c_center.rgb);

            vec4 z_center = imageLoad(in_linear_depth, p);
            const vec2 depth_grad = z_center.yz;
            if (any(isnan(z_center)))
            {
                imageStore(out_color, p, c_center);
                imageStore(out_specular, p, spec_center);
            }

            vec3 normal_center = unpack_gbuffer_normal(imageLoad(in_normal, p).rg);
            const float phi_lum = 10.f;
            const float deriv = max(abs(z_center.y), abs(z_center.z));
            const float phi_depth = max(deriv, 1e-8) * 3.0;

            const int r = 3;
            for (int yy = -r; yy <= r; ++yy)
            for (int xx = -r; xx <= r; ++xx)
            {
                ivec3 q = ivec3(p.xy + ivec2(xx, yy), p.z);
                if (all(lessThan(q.xy, control.size)) && all(greaterThanEqual(q.xy, ivec2(0))))
                {
                    vec3 q_color = imageLoad(in_color, q).rgb;
                    vec3 q_specular = imageLoad(in_specular, q).rgb;
                    vec2 q_moments = imageLoad(current_moments, q).rg;
                    float q_lum = rgb_to_luminance(q_color);
                    float q_z = imageLoad(in_linear_depth, q).r;
                    vec3 q_n = unpack_gbuffer_normal(imageLoad(in_normal, q).rg);
                    const float sigma_z = 1.0;
                    float w_n = pow(max(0.0, dot(q_n, normal_center)), 32.f);
                    float w_z = abs(q_z - z_center.x) / (sigma_z * abs(dot(depth_grad, p.xy - q.xy)) + 1e-6);

                    //float w_z = (phi_depth == 0) ? 0.0f : abs(q_z - z_center.x) / (phi_depth * length(vec2(xx, yy)));
                    float w_l = abs(q_lum - lum_center) / phi_lum;
                    float w = exp(-max(0.0, w_l) - max(0.0, w_z)) * w_n;

                    sum_w += w;
                    sum_color += q_color * w;
                    sum_specular += q_specular * w;
                    sum_moments += q_moments * w;
                }
            }

            sum_w = max(sum_w, 1e-6f);
            sum_color /= sum_w;
            sum_specular /= sum_w;
            sum_moments /= sum_w;

            float variance = sum_moments.y - sum_moments.x * sum_moments.x;
            variance *= 4.0 / hist_len;
            vec4 albedo = imageLoad(in_albedo, p);

            imageStore(out_color, p, vec4(sum_color.rgb, variance));
            imageStore(out_specular, p, vec4(sum_specular, variance));

            //imageStore(color_hist, p, vec4(sum_color, variance));
        }
        else
        {

            vec4 albedo = imageLoad(in_albedo, p);
            if (any(isnan(albedo)))
                albedo = vec4(0.0);
            imageStore(out_color, p, vec4(c_center));
            imageStore(out_specular, p, vec4(spec_center));
            //imageStore(color_hist, p, vec4(c_center));
        }

        //vec4 col = imageLoad(in_color, p);
        //vec2 linear_depth = imageLoad(in_linear_depth, p).rg;


        //imageStore(color_hist, p, vec4(col.rgb, 1.0));

        imageStore(moments_hist, p, vec4(moments, 0.0));
        // imageStore(out_color, p, vec4(col.rgb * albedo.rgb, 1.0));
        // imageStore(out_color, p, vec4(moments.xy, moments.z / 64.f, 1.0));
    }
}