#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#include "svgf.glsl"
#include "projection.glsl"
#include "gbuffer.glsl"
#include "color.glsl"

#define SQRD_DIST_LIMIT    0.01f
#define COS_LIMIT    0.90f
#define DISCARD_LIMIT 0.50f

layout (local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, set = 0, rgba32f) uniform readonly image2DArray in_color;
layout(binding = 1, set = 0, rg16_snorm) uniform readonly image2DArray in_normal;
layout(binding = 2, set = 0, rgba16f) uniform readonly image2DArray in_albedo;
layout(binding = 3, set = 0, rg16_snorm) uniform readonly image2DArray previous_normal;
layout(binding = 4, set = 0, rg32f) uniform readonly image2DArray in_screen_motion;
layout(binding = 5, set = 0, rgba32f) uniform readonly image2DArray previous_color;
layout(binding = 6, set = 0, rgba32f) uniform image2DArray out_color;
layout(binding = 8, set = 0, rgba32f) uniform image2DArray in_linear_depth;
layout(binding = 9, set = 0, rgba32f) uniform image2DArray previous_linear_depth;
layout(binding = 10, set = 0, rgba32f) uniform image2DArray previous_moments;
layout(binding = 11, set = 0, rgba32f) uniform image2DArray out_moments;
layout(binding = 12, set = 0, rgba32f) uniform readonly image2DArray in_diffuse;

layout(push_constant) uniform push_constant_buffer
{
    ivec2 size;
    int parity;
    int level;
    int stride;
    int iteration_count;
} control;

layout(binding = 7) buffer jitter_info_buffer
{
    vec4 jitter[];
} jitter_info;

bool temporal_reprojection_is_valid(ivec3 p, float z, float prev_z, float z_deriv, vec3 normal, vec3 prev_normal, float motion_z)
{
    if (any(greaterThanEqual(p.xy, control.size)) || any(lessThan(p.xy, ivec2(0))))
        return false;

    // if (abs(z - prev_z) / (z_deriv + 1e-2f) > 10.f)
    //     return false;
    if (isnan(z) || isnan(prev_z))
        return false;
    
    if (abs(prev_z - motion_z) / z > 0.05)
        return false;

    if (dot(normal, prev_normal) < 0.5)
        return false;

    return true;
}

void main()
{
    const ivec3 p = ivec3(gl_GlobalInvocationID.xyz);
    if(all(lessThan(p.xy, control.size)))
    {
        // Reproject
        vec4 jitter_history = jitter_info.jitter[p.z];
        vec2 cur_jitter = jitter_history.xy;
        vec2 prev_jitter = jitter_history.zw;

        vec4 full_motion = imageLoad(in_screen_motion, p);
        vec2 motion = full_motion.xy;
        motion -= (cur_jitter - prev_jitter)*0.5f;
        //debugPrintfEXT("cur jitter: %f %f, prev jitter: %f %f", cur_jitter.x, cur_jitter.y, prev_jitter.x, prev_jitter.y);
        motion.y = 1.f - motion.y;
        motion = motion * vec2(control.size) - vec2(0.5);

        vec3 normal = unpack_gbuffer_normal(imageLoad(in_normal, p).rg);
        vec2 depth = imageLoad(in_linear_depth, p).rg;

        vec4 prev_color = vec4(0.0);
        vec3 prev_moments = vec3(0.0);
        float history_length = 0.0;

        // Find valid samples
        const ivec2 offsets[4] = {ivec2(0, 0), ivec2(1, 0), ivec2(0, 1), ivec2(1, 1)};
        bool v[4];
        bool valid = false;
        for (int i = 0; i < 4; ++i)
        {
            ivec3 q = ivec3(floor(motion), p.z);
            q.xy += offsets[i];

            vec3 prev_normal = unpack_gbuffer_normal(imageLoad(previous_normal, q).rg);
            vec2 prev_depth = imageLoad(previous_linear_depth, q).rg;
            v[i] = temporal_reprojection_is_valid(q, depth.x, prev_depth.x, depth.y, normal, prev_normal, full_motion.z);
            valid = valid || v[i];
        }

        if (valid)
        {
            // We found some valid samples
            // Do bilinear filtering
            float sum_w = 0.f;
            float x = fract(motion.x);
            float y = fract(motion.y);
            const float w[4] = {(1.0 - x) * (1.0 - y),
                                       x  * (1.0 - y),
                                (1.0 - x) *         y,
                                x         *         y};

            for (int i = 0; i < 4; ++i)
            {
                ivec3 q = ivec3(floor(motion), p.z);
                q.xy += offsets[i];

                if (v[i])
                {
                    prev_color += w[i] * imageLoad(previous_color, q);
                    prev_moments += w[i] * imageLoad(previous_moments, q).xyz;
                    sum_w += w[i];
                }
            }

            valid = (sum_w > 0.01);
            prev_color = valid ? prev_color / sum_w : vec4(0.0);
            prev_moments = valid ? prev_moments / sum_w : vec3(0.0);
        }

        if (!valid)
        {
            // Temporal reprojection failed, desperately look for valid samples somewhere
            float n_valid = 0.f;

            const int r = 1;
            for (int yy = -r; yy <= r; ++yy)
            for (int xx = -r; xx <= r; ++xx)
            {
                ivec3 q = ivec3(floor(motion.xy + vec2(0.5)) + ivec2(xx, yy), p.z);
                vec3 prev_normal = unpack_gbuffer_normal(imageLoad(previous_normal, q).rg);
                vec2 prev_depth = imageLoad(previous_linear_depth, q).rg;

                if (temporal_reprojection_is_valid(q, depth.x, prev_depth.x, depth.y, normal, prev_normal, full_motion.z))
                {
                    prev_color += imageLoad(previous_color, q);
                    prev_moments += imageLoad(previous_moments, q).xyz;
                    n_valid += 1.0;
                }
            }

            if (n_valid > 0.0)
            {
                valid = true;
                prev_color /= n_valid;
                prev_moments /= n_valid;
            }
        }

        if (valid)
        {
            //history_length = prev_moments.z;
            history_length = imageLoad(previous_moments, ivec3(floor(motion.xy + vec2(0.5)), p.z)).z;
        }
        else
        {
            prev_color = vec4(0.0);
            prev_moments = vec3(0.0);
            history_length = 0.0;
        }



        vec4 current_color = imageLoad(in_color, p);
        vec4 current_albedo = imageLoad(in_albedo, p);
        vec3 c_curr = current_color.rgb / max(vec3(0.001), current_albedo.rgb);
        history_length = min(64.0, valid ? history_length + 1.0f : 1.0f);
        
        const float color_alpha = 0.02;
        const float moments_alpha = 0.10;
        float alpha = valid ? max(color_alpha, 1.0 / history_length) : 1.0;
        float alpha_moments = valid ? max(moments_alpha, 1.0 / history_length) : 1.0;

        //alpha = 1.0;
        //alpha_moments = 1.0;

        vec2 moments;
        moments.x = rgb_to_luminance(c_curr);
        moments.y = moments.x * moments.x;
        moments = mix(prev_moments.xy, moments, alpha_moments);

        float variance = max(0.f, moments.y - moments.x * moments.x);

        vec3 out_c = mix(prev_color.rgb, c_curr, alpha);

        imageStore(out_color, p, vec4(out_c, variance));
        imageStore(out_moments, p, vec4(moments.xy, 1.0 / alpha, 0.0));
    }
}
