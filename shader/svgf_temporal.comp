#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#include "svgf.glsl"
#include "projection.glsl"
#include "gbuffer.glsl"
#include "color.glsl"

#define CAMERA_DATA_BINDING 16

#include "scene.glsl"

#define SQRD_DIST_LIMIT    0.01f
#define COS_LIMIT    0.90f
#define DISCARD_LIMIT 0.50f

layout (local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, set = 0, rgba32f) uniform image2DArray in_color;
layout(binding = 1, set = 0, rg16_snorm) uniform readonly image2DArray in_normal;
layout(binding = 2, set = 0, rgba16f) uniform readonly image2DArray in_albedo;
layout(binding = 3, set = 0, rg16_snorm) uniform readonly image2DArray previous_normal;
layout(binding = 4, set = 0, rg32f) uniform readonly image2DArray in_screen_motion;
layout(binding = 5, set = 0, rgba32f) uniform readonly image2DArray previous_color;
layout(binding = 6, set = 0, rgba32f) uniform image2DArray out_color;
layout(binding = 8, set = 0, rgba32f) uniform image2DArray in_linear_depth;
layout(binding = 9, set = 0, rgba32f) uniform image2DArray previous_linear_depth;
layout(binding = 10, set = 0, rgba32f) uniform image2DArray previous_moments;
layout(binding = 11, set = 0, rgba32f) uniform image2DArray out_moments;
layout(binding = 12, set = 0, rgba32f) uniform readonly image2DArray in_diffuse;
layout(binding = 13, set = 0, rgba32f) uniform readonly image2DArray previous_specular;
layout(binding = 14, set = 0, rgba32f) uniform image2DArray out_specular;
layout(binding = 15, set = 0, rgba32f) uniform image2DArray in_material;
layout(binding = 17, set = 0, rgba32f) uniform image2DArray prev_material;

float saturate( float x ) { return clamp( x, 0.0, 1.0 ); }

vec3 viridis_quintic( float x )
{
	x = saturate( x );
	vec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3
	vec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7
	return vec3(
		dot( x1.xyzw, vec4( +0.280268003, -0.143510503, +2.225793877, -14.815088879 ) ) + dot( x2.xy, vec2( +25.212752309, -11.772589584 ) ),
		dot( x1.xyzw, vec4( -0.002117546, +1.617109353, -1.909305070, +2.701152864 ) ) + dot( x2.xy, vec2( -1.685288385, +0.178738871 ) ),
		dot( x1.xyzw, vec4( +0.300805501, +2.614650302, -12.019139090, +28.933559110 ) ) + dot( x2.xy, vec2( -33.491294770, +13.762053843 ) ) );
}

layout(push_constant) uniform push_constant_buffer
{
    ivec2 size;
    int parity;
    int level;
    int stride;
    int iteration_count;
} control;

layout(binding = 7) buffer jitter_info_buffer
{
    vec4 jitter[];
} jitter_info;

bool temporal_reprojection_is_valid(ivec3 p, float z, float prev_z, float z_deriv, vec3 normal, vec3 prev_normal, float motion_z, float fnormal)
{
    if (any(greaterThanEqual(p.xy, control.size)) || any(lessThan(p.xy, ivec2(0))))
        return false;

    /*if (isnan(z) || isnan(prev_z))
        return false;

    if (abs(z - prev_z) / (z_deriv + 1e-2f) > 10.f)
        return false;

    if (distance(normal, prev_normal) / (fnormal + 1e-2) > 16.0)
        return false;*/

    //if (p.xy == ivec2(640, 360))
    //   debugPrintfEXT("fnorm: %f, z_diff: %f, z_deriv: %f", fnormal, abs(z - prev_z), z_deriv);
    if (isnan(z) || isnan(prev_z))
        return false;

    if (abs(prev_z - motion_z) / z > 0.05)
        return false;

    if (dot(normal, prev_normal) < 0.5)
        return false;

    return true;
}

void main()
{
    const ivec3 p = ivec3(gl_GlobalInvocationID.xyz);
    if(all(lessThan(p.xy, control.size)))
    {
        // Reproject
        vec4 jitter_history = jitter_info.jitter[p.z];
        vec2 cur_jitter = jitter_history.xy;
        vec2 prev_jitter = jitter_history.zw;

        vec4 full_motion = imageLoad(in_screen_motion, p);
        vec2 motion = full_motion.xy;
        motion -= (cur_jitter - prev_jitter)*0.5f;
        //debugPrintfEXT("cur jitter: %f %f, prev jitter: %f %f", cur_jitter.x, cur_jitter.y, prev_jitter.x, prev_jitter.y);
        motion.y = 1.f - motion.y;
        motion = motion * vec2(control.size)- vec2(0.5);

        mat4 view = camera.pairs[p.z].current.view;
        mat4 prev_view = camera.pairs[p.z].previous.view;

        vec3 normal = unpack_gbuffer_normal(imageLoad(in_normal, p).rg);
        vec3 view_normal = mat3(view) * normal;
        vec4 depth = imageLoad(in_linear_depth, p);
        vec2 depth_grad = depth.yz;
        const float deriv = max(abs(depth.y), abs(depth.z));
        vec2 mat = imageLoad(in_material, p).rg;
        float shininess = clamp(2.0 / (mat.g * mat.g * mat.g * mat.g) - 2.0, 0.0, 32.0);
;
        vec4 prev_color = vec4(0.0);
        vec4 prev_diffuse = vec4(0.0);
        vec4 prev_specular = vec4(0.0);
        vec3 prev_moments = vec3(0.0);
        float history_length = 0.0;

        // Find valid samples
        const ivec2 offsets[4] = {ivec2(0, 0), ivec2(1, 0), ivec2(0, 1), ivec2(1, 1)};
        bool v[4];
        bool valid = false;
        for (int i = 0; i < 4; ++i)
        {
            ivec3 q = ivec3(floor(motion), p.z);
            q.xy += offsets[i];

            vec3 prev_normal = unpack_gbuffer_normal(imageLoad(previous_normal, q).rg);
            vec4 prev_depth = imageLoad(previous_linear_depth, q);
            v[i] = temporal_reprojection_is_valid(q, depth.x, prev_depth.x, deriv, normal, prev_normal, full_motion.z, depth.w);
            valid = valid || v[i];
        }

        float alpha_spec = 0.f;
        float sum_alpha_w = 0.f;
        if (valid)
        {
            // We found some valid samples
            // Do bilinear filtering
            float sum_w = 0.f;
            float sum_w_spec = 0.f;
            float x = fract(motion.x);
            float y = fract(motion.y);
            const float w[4] = {(1.0 - x) * (1.0 - y),
                                       x  * (1.0 - y),
                                (1.0 - x) *         y,
                                x         *         y};

            for (int i = 0; i < 4; ++i)
            {
                ivec3 q = ivec3(floor(motion), p.z);
                q.xy += offsets[i];

                if (v[i])
                {
                    vec3 prev_normal = unpack_gbuffer_normal(imageLoad(previous_normal, q).rg);
                    vec4 prev_depth = imageLoad(previous_linear_depth, q);
                    vec3 prev_view_normal = mat3(prev_view) * prev_normal;
                    vec2 prev_mat = imageLoad(prev_material, q).rg;
                    if (p.xy == ivec2(640, 360))
                        debugPrintfEXT("prev_view_normal: %f %f %f", prev_view_normal.x, prev_view_normal.y, prev_view_normal.z);
                    float w_diff = w[i] * max(dot(prev_normal, normal), 0.0);
                    float view_dot = pow(max(0.0, dot(prev_view_normal, view_normal)), shininess);
                    float angle_w = (1.0 - view_dot) * view_normal.z;
                    float w_spec = w[i] * view_dot;
                    float sigma_z = 10.0;
                    float sigma_n = 32.0;
                    float r_max = 0.1;
                    float r_near = 0.01;
                    float r_far = 0.1;

                    float w_r = 1.0 - smoothstep(r_near, r_far, abs(prev_mat.g - mat.g));
                    float w_n = pow(max(0.0, dot(prev_view_normal, view_normal)), sigma_n);
                    float w_r_max = smoothstep(0.0, r_max, mat.g);
                    float w_z = abs(prev_depth.x - depth.x) / (sigma_z * abs(dot(depth_grad, p.xy - q.xy)) + 1e-6);
                    float gamma = 0.95 * w_r * w_n * w_r_max;//  * exp(-w_z);
                    alpha_spec += w[i] * gamma;
                    sum_alpha_w += w[i];
                    w_spec = w[i] * gamma;
                    //w_spec = 0.0;
                    // float angle = clamp(1.0f - acos(
                    //     clamp(dot(prev_view_normal, view_normal), 0.0f, 0.999999f)
                    // )/M_PI*2.0, 0.001f, 1.0f);
                    // float w_spec = w[i] * pow(angle, 2.0f / max(mat.g, 1e-2));
                    // w_spec = 1.0;

                    prev_color += w_diff * imageLoad(previous_color, q);
                    prev_specular += w_spec * imageLoad(previous_specular, q);
                    prev_moments += w_diff * imageLoad(previous_moments, q).xyz;
                    sum_w += w_diff;
                    sum_w_spec += w_spec;
                }
            }

            valid = (sum_w > 0.01);
            prev_color = valid ? prev_color / sum_w : vec4(0.0);
            prev_specular = valid ? prev_specular / sum_w_spec : vec4(0.0);
            prev_moments = valid ? prev_moments / sum_w : vec3(0.0);
            alpha_spec = valid ? alpha_spec / sum_alpha_w : 0.0;
        }

        if (!valid)
        {
            // Temporal reprojection failed, desperately look for valid samples somewhere
            float n_valid = 0.f;

            const int r = 1;
            for (int yy = -r; yy <= r; ++yy)
            for (int xx = -r; xx <= r; ++xx)
            {
                ivec3 q = ivec3(floor(motion.xy + vec2(0.5)) + ivec2(xx, yy), p.z);
                vec3 prev_normal = unpack_gbuffer_normal(imageLoad(previous_normal, q).rg);
                vec2 prev_depth = imageLoad(previous_linear_depth, q).rg;

                if (temporal_reprojection_is_valid(q, depth.x, prev_depth.x, deriv, normal, prev_normal, full_motion.z, depth.w))
                {
                    prev_color += imageLoad(previous_color, q);
                    prev_specular += imageLoad(previous_specular, q);
                    prev_moments += imageLoad(previous_moments, q).xyz;
                    n_valid += 1.0;
                }
            }

            if (n_valid > 0.0)
            {
                valid = true;
                prev_color /= n_valid;
                prev_specular /= n_valid;
                prev_moments /= n_valid;
            }
        }

        if (valid)
        {
            //history_length = prev_moments.z;
            history_length = imageLoad(previous_moments, ivec3(floor(motion.xy + vec2(0.5)), p.z)).z;
        }
        else
        {
            prev_color = vec4(0.0);
            prev_specular = vec4(0.0);
            prev_moments = vec3(0.0);
            history_length = 0.0;
        }

        if (p.xy == ivec2(640, 360))
            debugPrintfEXT("alpha_spec: %f", alpha_spec);

        vec4 current_color = imageLoad(in_color, p);
        if (any(isnan(current_color))) current_color = vec4(0.0);
        vec4 current_diffuse = imageLoad(in_diffuse, p);
        if (any(isnan(current_diffuse))) current_diffuse = vec4(0.0);
        vec4 current_albedo = imageLoad(in_albedo, p);
        vec4 current_specular = current_color - current_diffuse * current_albedo;
        if (any(isnan(current_specular)))  current_specular = vec4(0.0);
        vec3 c_curr = current_color.rgb / max(vec3(0.001), current_albedo.rgb);
        history_length = min(256.0, valid ? history_length + 1.0f : 1.0f);

        const float color_alpha = 0.01;
        const float moments_alpha = 0.20;
        float alpha = valid ? max(color_alpha, 1.0 / history_length) : 1.0;
        float alpha_moments = valid ? max(moments_alpha, 1.0 / history_length) : 1.0;

        //alpha = 1.0;
        //alpha_moments = 1.0;
        //imageStore(in_color, p, vec4(viridis_quintic(alpha), 1.0));

        vec2 moments;
        moments.x = rgb_to_luminance(c_curr);
        moments.y = moments.x * moments.x;
        moments = mix(prev_moments.xy, moments, alpha_moments);

        float variance = max(0.f, moments.y - moments.x * moments.x);

        vec3 out_c = mix(prev_color.rgb, c_curr, alpha);
        vec3 out_diff = mix(prev_color.rgb, current_diffuse.rgb, alpha);
        vec3 out_spec = mix(prev_specular.rgb, current_specular.rgb, alpha);
        if (any(isnan(out_spec))) out_spec = vec3(0.0);

        if (any(isnan(out_c)))  debugPrintfEXT("nan");
        //imageStore(out_color, p, vec4(out_c, variance));
        imageStore(out_color, p, vec4(out_diff, variance));
        imageStore(out_specular, p, vec4(out_spec, variance));
        imageStore(out_moments, p, vec4(moments.xy, 1.0 / alpha, 0.0));
    }
}
