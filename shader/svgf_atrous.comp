#version 460
#extension GL_GOOGLE_include_directive : enable
#include "svgf.glsl"
#include "projection.glsl"
#include "gbuffer.glsl"
#include "color.glsl"
#include "random_sampler.glsl"

layout (local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, set = 0, rgba32f) uniform image2DArray diffuse_in;
layout(binding = 1, set = 0, rgba32f) uniform image2DArray diffuse_out;
layout(binding = 2, set = 0, rgba32f) uniform image2DArray diffuse_hist;
layout(binding = 3, set = 0, rgba32f) uniform image2DArray final_output;
layout(binding = 4, set = 0, rgba32f) uniform image2DArray in_linear_depth;
layout(binding = 5, set = 0, rgba32f) uniform image2DArray in_normal;
layout(binding = 6, set = 0, rgba32f) uniform image2DArray in_albedo;
layout(binding = 7, set = 0, rgba32f) uniform image2DArray specular_in;
layout(binding = 8, set = 0, rgba32f) uniform image2DArray specular_out;
layout(binding = 9, set = 0, rgba32f) uniform image2DArray spec_hist;
layout(binding = 10, set = 0, rgba32f) uniform image2DArray in_material;
layout(binding = 11, set = 0, rgba32f) uniform image2DArray in_moments;
layout(binding = 12, set = 0, rgba32f) uniform image2DArray world_position;
layout(binding = 13) buffer uniforms
{
    uint frame_index;
} uniforms_buffer;
layout(binding = 14, set = 0, rgba32f) uniform image2DArray raw_diffuse;


float filter_variance(ivec3 p)
{
    float sum = 0.f;

    const int r = 1;
    for (int yy = -r; yy <= r; ++yy)
    for (int xx = -r; xx <= r; ++xx)
    {
        const ivec3 q = p + ivec3(xx, yy, 0.0);
        const float k = gaussian_kernel[abs(xx)][abs(yy)];
        float v = imageLoad(diffuse_in, q).a;
        sum += v * k;
    }

    return sum;
}

#if 1

void main()
{
    const ivec3 p = ivec3(gl_GlobalInvocationID.xyz);
    if(!is_in_screen(p.xy)) return;
    const vec4 center_depth = imageLoad(in_linear_depth, p);
    vec4 center_color = imageLoad(diffuse_in, p);
    vec4 filtered_spec = imageLoad(specular_in, p);

    vec4 out_color = center_color;
    vec3 moments = imageLoad(in_moments, p).xyz;

#if ATROUS_ENABLED == 1
    vec3 center_pos = imageLoad(world_position, p).xyz;
    if (any(isnan(center_pos)))
    {  
        imageStore(diffuse_out, p, center_color);
        imageStore(specular_out, p, filtered_spec);
        return;
    }

    float history_length = moments.z;

    float center_luminance = rgb_to_luminance(center_color.rgb);
    float center_variance = center_color.a;
    float luminance_std_dev = sqrt(center_variance);
    vec3 center_normal = unpack_gbuffer_normal(imageLoad(in_normal, p).rg);
    float frustum_size = control.min_rect_dim_mul_unproject * abs(center_depth.x);
    float inv_dist_to_point = 1.0 / frustum_size;
    const float plane_dist_sensitivity = 0.005;
    float plane_dist_scale = inv_dist_to_point / plane_dist_sensitivity;

    const int radius = ATROUS_RADIUS;
    const int stride = int(1u << control.iteration);

    float lobe_angle_fraction = 0.5;
    lobe_angle_fraction = mix(lobe_angle_fraction, 1.0, 1.0 / history_length);
    lobe_angle_fraction /= sqrt(float(stride));
    const float spec_half_angle = get_specular_lobe_half_angle(lobe_angle_fraction, 1.0);

    vec2 metallic_roughness = imageLoad(in_material, p).rg;

    ivec2 offset = ivec2(0);
#if ATROUS_RANDOM_OFFSET == 1
    if (control.iteration > 2)
    {
        random_sampler rs = init_random_sampler(uvec4(p.xyz, uniforms_buffer.frame_index));
        vec4 r = generate_uniform_random(rs);
        offset = ivec2(stride * (r.xy - 0.5) * .5);
    }
#endif

    float w_sum = gaussian_kernel[0][0];
    vec4 color_sum = vec4(center_color.rgb, center_variance) * vec4(vec3(w_sum), w_sum * w_sum);
    for (int y = -radius; y <= radius; ++y)
    {
        for (int x = -radius; x <= radius; ++x)
        {
            ivec3 q = ivec3(p.xy + ivec2(x, y) * stride + offset, p.z);

            if (y == 0 && x == 0) continue;
            if (!is_in_screen(q.xy)) continue;

            const vec4 color_q = imageLoad(diffuse_in, q);

            vec3 X = imageLoad(world_position, q).xyz;
            if (any(isnan(X))) continue;
            vec3 N = unpack_gbuffer_normal(imageLoad(in_normal, q).rg);
            float plane_dist = abs(dot((X - center_pos), center_normal) * plane_dist_scale);
            float w_geom = smoothstep(1, 0, plane_dist);
            //float w_geom = step(plane_dist, 1.0);

#if ATROUS_RADIUS == 1
            float kernel = gaussian_kernel[abs(x)][abs(y)];
#elif ATROUS_RADIUS == 2
            float kernel = gaussian_kernel_5x5[abs(x)][abs(y)];
#else
            float kernel = 1.0;
#endif

            float ndotn = saturate(dot(N, center_normal));
            float angle = acos(ndotn);
            float angle_percentage = angle / spec_half_angle;
            float w_normal = exp(-3.0 * angle_percentage);

            const float sigma_l = 2.0f;
            float sample_luminance = rgb_to_luminance(color_q.rgb);
            float w_lum = abs(sample_luminance - center_luminance) / (sigma_l * luminance_std_dev + 1e-3);
            w_lum = exp(-w_lum);
            
            float w = 1.0;
            w *= w_geom;
            w *= w_normal;
            w *= kernel;
            w *= w_lum;
            if (w > 1e-4)
            {
                color_sum += vec4(color_q.rgb * w, color_q.a * w * w);
                w_sum += w;
            }
        }
    }

    w_sum = max(w_sum, 1e-4);
    color_sum /= vec4(vec3(w_sum), w_sum * w_sum);

    if (control.iteration < ATROUS_ITERATIONS)
    {
        out_color = color_sum;
    }

#endif

    if (control.iteration == 0)
    {
        // imageStore(diffuse_hist, p, center_color);
        // imageStore(spec_hist, p, filtered_spec);
    }
    if (control.iteration == control.iteration_count - 1)
    {
        vec4 albedo = imageLoad(in_albedo, p);
#if FINAL_OUTPUT == OUTPUT_DENOISED_DIFFUSE
        imageStore(final_output, p, vec4(out_color.rgb, 1.0));
#elif FINAL_OUTPUT == OUTPUT_VARIANCE
        imageStore(final_output, p, vec4(vec3(out_color.a), 1.0));
#elif FINAL_OUTPUT == OUTPUT_HIST_LENGTH
        imageStore(final_output, p, vec4(viridis_quintic(moments.z / MAX_ACCUMULATED_FRAMES), 1.0));
#elif FINAL_OUTPUT == OUTPUT_UNFILTERED_VARIANCE
        float variance = moments.y - moments.x * moments.x;
        imageStore(final_output, p, vec4(vec3(variance), 1.0));
#elif FINAL_OUTPUT == OUTPUT_REMODULATED_DENOISED_DIFFUSE
        vec3 remodulated = albedo.xyz * out_color.rgb;
        imageStore(final_output, p, vec4(remodulated, 1.0));
#elif FINAL_OUTPUT == OUTPUT_DENOISED_SPECULAR
        imageStore(final_output, p, vec4(filtered_spec.rgb, 1.0));
#elif FINAL_OUTPUT == OUTPUT_REMODULATED_DENOISED_DIFFUSE_AND_SPECULAR
        vec3 remodulated = albedo.rgb * mix(out_color.rgb, filtered_spec.rgb, metallic_roughness.x) + filtered_spec.rgb * (1.0 - metallic_roughness.x);
        imageStore(final_output, p, vec4(remodulated.rgb, 1.0));
#elif FINAL_OUTPUT == OUTPUT_DIFFUSE_HITDIST
        vec4 noisy_diffuse = imageLoad(raw_diffuse, p);
        imageStore(final_output, p, vec4(vec3(noisy_diffuse.a), 1.0));
#endif  
    }
    else
    {
        imageStore(diffuse_out, p, out_color);
        imageStore(specular_out, p, filtered_spec);
    }
}

#else
void main()
{
    const ivec3 p = ivec3(gl_GlobalInvocationID.xyz);
    if(all(lessThan(p.xy, control.size)))
    {
        const vec4 z_center = imageLoad(in_linear_depth, p);
        vec4 center_color = imageLoad(diffuse_in, p);
        vec4 center_specular = imageLoad(specular_in, p);

        if (any(isnan(z_center)))
        {
            imageStore(diffuse_out, p, center_color);
            imageStore(specular_out, p, center_specular);
            return;
        }

        const int step_size = int(1u << control.iteration);

        float center_luminance = rgb_to_luminance(center_color.rgb);

        const vec3 n_center = unpack_gbuffer_normal(imageLoad(in_normal, p).xy);
        const float roughness_center = imageLoad(in_material, p).y;

        const float var = filter_variance(p);

        const float phi_color = control.sigma_l *  sqrt(max(0.0, var)) + 1e-2;
        const vec2 depth_grad = z_center.yz;

        vec4 sum_color = center_color;
        vec4 sum_specular = center_specular;
        float sum_w = 1.0;
        float sum_w_spec = 1.0;

        const int r = control.atrous_kernel_radius;
        for (int yy = -r; yy <= r; ++yy)
        for (int xx = -r; xx <= r; ++xx)
        {
            const ivec3 q  = p + ivec3(xx, yy, 0) * step_size;

            if (all(lessThan(q.xy, control.size)) && all(greaterThanEqual(q.xy, ivec2(0))) && !(xx == 0 && yy == 0))
            {
                const vec4 color_q = imageLoad(diffuse_in, q);
                const vec4 spec_q = imageLoad(specular_in, q);
                const float lum_q = rgb_to_luminance(color_q.rgb);
                const float z_q = imageLoad(in_linear_depth, q).r;
                const vec3 n_q = unpack_gbuffer_normal(imageLoad(in_normal, q).rg);
                const float roughness_q = imageLoad(in_material, q).y;

                float w_n = pow(max(0.0, dot(n_q, n_center)), control.sigma_n);
                float w_z = abs(z_q - z_center.x) / (control.sigma_z * abs(dot(depth_grad, p.xy - q.xy)) + 1e-6);
                float w_l = abs(lum_q - center_luminance) / phi_color;
                float w = w_n * exp(-max(0.0, w_z) - max(0.0, w_l));

                float r_max = 0.1;
                float r_near = 0.01;
                float r_far = 0.1;
                float d_near = 10.0 * roughness_center;
                float d_far = 70.0 * roughness_center;
                float w_r = 1.0 - smoothstep(r_near, r_far, abs(roughness_q - roughness_center));
                float w_d = 1.0 - smoothstep(d_near, d_far, length(vec3(p - q)));

                float w_spec = exp(-max(0.0, w_z)) * w_n * w_r * w_d;
                sum_w += w;
                sum_color += color_q * vec4(vec3(w), w * w);
                if (control.iteration < control.spec_iteration_count)
                {
                    sum_w_spec += w_spec;
                    sum_specular += spec_q * vec4(vec3(w_spec), w_spec * w_spec);
                }
            }
        }

        vec4 filtered_color = sum_color / vec4(vec3(sum_w), sum_w * sum_w);
        vec4 filtered_spec = sum_specular / vec4(vec3(sum_w_spec), sum_w_spec * sum_w_spec);
        if (control.iteration == 0)
        {
            imageStore(diffuse_hist, p, center_color);
            imageStore(spec_hist, p, filtered_spec);
        }
        if (control.iteration == control.iteration_count - 1)
        {
            vec4 albedo = imageLoad(in_albedo, p);
#if FINAL_OUTPUT == OUTPUT_DENOISED_DIFFUSE
            imageStore(final_output, p, vec4(center_color.rgb, 1.0));
#elif FINAL_OUTPUT == OUTPUT_VARIANCE
            imageStore(final_output, p, vec4(vec3(center_color.a), 1.0));
#elif FINAL_OUTPUT == OUTPUT_UNFILTERED_VARIANCE
            imageStore(final_output, p, vec4(vec3(moments.y - moments.x * moments.x), 1.0));
            imageStore(final_output, p, vec4(vec3(1.0, 0.0, 1.0), 1.0));
#endif
        }
        else
        {
            imageStore(diffuse_out, p, center_color);
            imageStore(specular_out, p, filtered_spec);
        }
    }
}

#endif