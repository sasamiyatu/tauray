#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable

#include "svgf.glsl"
#include "gbuffer.glsl"
#include "random_sampler.glsl"
#include "math.glsl"

layout(binding = 0, set = 0, rgba32f) uniform readonly image2DArray in_diffuse;
layout(binding = 1, set = 0, rgba32f) uniform readonly image2DArray normal;
layout(binding = 2, set = 0, rgba32f) uniform readonly image2DArray world_position;
layout(binding = 3, set = 0, rgba32f) uniform readonly image2DArray linear_depth;
layout(binding = 4, set = 0, rgba32f) uniform image2DArray out_diffuse;
layout(binding = 5) buffer uniforms
{
    uint frame_index;
} uniforms_buffer;

const vec3 poisson_disk[8] = {
    // https://www.desmos.com/calculator/abaqyvswem
    vec3( -1.00             ,  0.00             , 1.0 ),
    vec3(  0.00             ,  1.00             , 1.0 ),
    vec3(  1.00             ,  0.00             , 1.0 ),
    vec3(  0.00             , -1.00             , 1.0 ),
    vec3( -0.25 * sqrt(2.0) ,  0.25 * sqrt(2.0) , 0.5 ),
    vec3(  0.25 * sqrt(2.0) ,  0.25 * sqrt(2.0) , 0.5 ),
    vec3(  0.25 * sqrt(2.0) , -0.25 * sqrt(2.0) , 0.5 ),
    vec3( -0.25 * sqrt(2.0) , -0.25 * sqrt(2.0) , 0.5 )
};

layout (local_size_x = 16, local_size_y = 16) in;
void main()
{
    const ivec3 p = ivec3(gl_GlobalInvocationID.xyz);
    if (!all(lessThan(p.xy, control.size))) return;

    float blur_radius = PREPASS_BLUR_RADIUS;

    vec4 depth = imageLoad(linear_depth, p);
    const float Z = abs(depth.x);
    const float frustum_size = control.min_rect_dim_mul_unproject * Z;
    const float inv_dist_to_point = 1.0 / frustum_size;
    
    vec4 color = imageLoad(in_diffuse, p);

    float hit_dist = color.a != 0.0 ? 1.0 / color.a : 1.0;
    //hit_dist = 1.0;
    blur_radius *= saturate(hit_dist * inv_dist_to_point);
    blur_radius = max(blur_radius, 1.0);

    const float plane_dist_sensitivity = 0.005;
    const float plane_dist_scale = inv_dist_to_point / plane_dist_sensitivity;

    const float spec_half_angle = get_specular_lobe_half_angle(0.75, 1.0);

    vec3 center_pos = imageLoad(world_position, p).xyz;
    vec3 center_normal = unpack_gbuffer_normal(imageLoad(normal, p).xy);

    float w_sum = 1.0;

    random_sampler rs = init_random_sampler(uvec4(p, uniforms_buffer.frame_index));
    vec4 r = generate_uniform_random(rs);
    float theta = r.x * 2.0 * M_PI;
    float cx = cos(theta);
    float sx = sin(theta);
    mat2 rot = mat2(cx, sx, -sx, cx);
    //rot = mat2(1.0);
    // if (p.xy == ivec2(640, 360))
    // {
    //     debugPrintfEXT("frustum_size: %f\n", frustum_size);
    // }

#if PREPASS_ENABLED == 1
    for (int i = 0; i < 8; ++i)
    {
        ivec3 q = ivec3(p.xy + rot * poisson_disk[i].xy * blur_radius, p.z);

        if (!is_in_screen(q.xy)) continue;

        vec3 X = imageLoad(world_position, q).xyz;
        if (any(isnan(X))) continue;
        vec4 c = imageLoad(in_diffuse, q);

        float plane_dist = abs(dot((X - center_pos), center_normal) * plane_dist_scale);
        float plane_dist_weight = step(plane_dist, 1);

        vec3 Ns = unpack_gbuffer_normal(imageLoad(normal, q).rg);
        float ndotn = saturate(dot(Ns, center_normal));
        float angle = acos(ndotn);
        float angle_percentage = angle / spec_half_angle;
        float normal_weight = exp(-3.0 * angle_percentage);

        float r = poisson_disk[i].z;
        float gaussian_weight = exp( -0.66 * r * r );

        float w = 1.0;
        w *= plane_dist_weight;
        w *= normal_weight;
        w *= gaussian_weight;

        color += c * w;
        w_sum += w;
    }

    color /= max(1e-4, w_sum);
    //color.xyz = vec3(r.x);
#endif

    imageStore(out_diffuse, p, color);
}